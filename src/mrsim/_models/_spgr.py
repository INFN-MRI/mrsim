"""Spoiled GRE simulation sub-routines."""

__all__ = ["spgr"]


import math


import numpy.typing as npt


import torch


from ._decorators import torchify, simulator


ARGMAP = {"T1": 0, "T2star": 1}


@torchify
def spgr(
    T1: float | npt.ArrayLike,
    T2star: float | npt.ArrayLike,
    TR: float | npt.ArrayLike,
    TE: float | npt.ArrayLike,
    alpha: float | npt.ArrayLike,
    M0: float | npt.ArrayLike = 1.0,
    field_map: float | npt.ArrayLike = 0.0,
    delta_cs: float | npt.ArrayLike = 0.0,
    diff: str | tuple[str] | None = None,
):  # noqa
    r"""bSSFP transverse signal at time TE after excitation.

    Parameters
    ----------
    T1 : float | npt.ArrayLike
        longitudinal exponential decay time constant (in ms).
    T2star : float | npt.ArrayLike
        effective transverse exponential decay time constant (in ms).
    TE : float | npt.ArrayLike
        echo time (in ms).
    TR : float | npt.ArrayLike
        repetition time (in ms).
    alpha : float | npt.ArrayLike
        flip angle (in deg).
    M0 : float | npt.ArrayLike
        proton density.
    field_map : float | npt.ArrayLike, optional
        B0 field map (in Hz).
    delta_cs : float | npt.ArrayLike, optional
        chemical shift of species w.r.t. the water peak (in Hz).
    diff : str | tuple[str], optional
       String or tuple of strings, saying which arguments
       to get the signal derivative with respect to.
       Defaults to ``None`` (no differentation).

    Returns
    -------
    Mxy : numpy.ndarray
        Transverse complex magnetization.

    Notes
    -----
    ``T1``, ``T2s``, ``TR``, ``TE``, ``alpha``, ``field_map`` and ``M0`` can all be
    either scalars or arrays.

    Output shape is determined by the shapes of input arrays.  All input
    arrays with equal shape will be assumed to have overlapping axes.  All
    input arrays with unique shapes will be assumed to have distinct axes
    and will be broadcast appropriately.

    Assuming a longitudinal steady-state and perfect spoiling. Note
    that dependence is on T2* rather than T2 because SE/STE formation
    is suppressed by spoiling and the signal is generated by gradient
    refocusing of an FID.

    Implements equation [14.8] from [1]_.

    References
    ----------
    .. [1] Notes from Bernstein, M. A., King, K. F., & Zhou, X. J.
           (2004). Handbook of MRI pulse sequences. Elsevier.

    """
    return _spgr(
        T1,
        T2star,
        M0,
        field_map,
        delta_cs,
        TR,
        TE,
        alpha,
        diff,
    )


# %% subroutines
def _get_spgr_phase(T2star, TE, field_map, delta_cs):
    """Additional SPGR phase factors."""
    # Enable broadcasting
    T2star = T2star.unsqueeze(-1)
    delta_cs = delta_cs.unsqueeze(-1)
    field_map = field_map.unsqueeze(-1)
    TE = TE.unsqueeze(0)

    # Compute total phase accrual
    phi = 2 * math.pi * (delta_cs + field_map) * TE

    # Compute signal dampening
    exp_term = torch.exp(-TE / T2star)
    exp_term = torch.nan_to_num(exp_term, nan=0.0, posinf=0.0, neginf=0.0)

    return torch.exp(1j * phi) * exp_term


@simulator(ARGMAP, n_diff_args=2, n_batched_args=5)
def _spgr(
    T1,
    T2star,
    M0,
    field_map,
    delta_cs,
    TR,
    TE,
    alpha,
):
    # Unit conversion
    T1 = T1 * 1e-3  # ms -> s
    T2star = T2star * 1e-3  # ms -> s
    TE = TE * 1e-3  # ms -> s
    TR = TR * 1e-3  # ms -> s
    alpha = torch.deg2rad(alpha)

    # We are assuming Freeman-Hill convention for off-resonance map,
    # so we need to negate to make use with this Ernst-Anderson-based implementation from Hoff
    field_map = -1 * field_map

    # divide-by-zero risk with PyTorch's nan_to_num
    E1 = torch.exp(
        -1
        * torch.nan_to_num(
            TR.unsqueeze(0) / T1.unsqueeze(-1), nan=0.0, posinf=0.0, neginf=0.0
        )
    )

    # Precompute cos, sin
    ca = torch.cos(alpha).unsqueeze(0)
    sa = torch.sin(alpha).unsqueeze(0)

    # Main calculation
    den = 1 - E1 * ca
    Mxy = M0 * ((1 - E1) * sa) / den
    Mxy = torch.nan_to_num(Mxy, nan=0.0, posinf=0.0, neginf=0.0)

    # Add additional phase factor for readout at TE.
    signal = Mxy * _get_spgr_phase(T2star, TE, field_map, delta_cs)

    # Move multi-contrast in front
    signal = signal.unsqueeze(0)
    signal = signal.swapaxes(0, -1)

    return signal.squeeze().to(torch.complex64)
